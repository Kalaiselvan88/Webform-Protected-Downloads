<?php

use Drupal\Component\Utility\Crypt;
use Drupal\Core\Render\BubbleableMetadata;
use Drupal\Core\Link;
use Drupal\Core\Url;

/**
 * Add a webform protected download submission to the db.
 * Implements hook_webform_submission_insert.
 */
function webform_protected_downloads_webform_submission_insert($submission) {

  // Get submission's corresponding webform's settings.
  $webform = $submission->getWebform();
  $protected_downloads_settings = $webform->getThirdPartySettings('webform_protected_downloads');

  // Return if protected downloads setting is not enabled.
  if (!isset($protected_downloads_settings['enabled_protected_files']) || !$protected_downloads_settings['enabled_protected_files']) {
    return;
  }
  // Return if protected file is not set.
  elseif (!isset($protected_downloads_settings['protected_file']) || empty($protected_downloads_settings['protected_file'])) {
    return;
  }

  // Prepare all the needed values.
  $fields = [];
  $fields['submission_uuid'] = $submission->uuid();
  $fields['wid'] = $webform->id();
  reset($protected_downloads_settings['protected_file']);
  $fields['fid'] = current($protected_downloads_settings['protected_file']);
  $fields['hash'] = Crypt::hashBase64($fields['submission_uuid'] . time());
  $fields['expire'] = (!$protected_downloads_settings['expire_after']) ? 0 : time() + $protected_downloads_settings['expire_after'] * 60;
  $fields['active'] = TRUE;
  $fields['onetime'] = $protected_downloads_settings['enabled_onetime'];

  // Insert to database.
  $db = \Drupal::database();
  $db->insert('webform_protected_downloads')->fields($fields)->execute();
}

/**
 * Set a custom token.
 * Implements hook_token_info().
 */
function webform_protected_downloads_token_info() {
  $type = array(
    'name' => t('Webform protected downloads'),
    'description' => t('Webform protected downloads tokens.'),
    'needs-data' => 'webform',
  );
  $submission['protected_download_url'] = array(
    'name' => t("Download link"),
    'description' => t("Download link for webform protected downloads."),
  );
  return array(
    'types' => array('webform_submission' => $type),
    'tokens' => array('webform_submission' => $submission),
  );
}

/**
 * Replaces protected_download_url token with the download link.
 * Implements hook_tokens().
 */
function webform_protected_downloads_tokens($type, $tokens, array $data, array $options, BubbleableMetadata $bubbleable_metadata) {
  $replacements = [];

  if (isset($tokens['protected_download_url']) && isset($data['entity'])) {
    foreach ($tokens as $name => $original) {
      switch ($name) {
        case 'protected_download_url':

          // Find a file hash for current submission.
          $submission = $data["entity"];
          $db = \Drupal::database();
          $query = $db->select('webform_protected_downloads', 'wpd')
            ->fields('wpd', ['fid', 'hash', 'active', 'expire', 'onetime'])
            ->condition('wpd.submission_uuid', $submission->uuid())
            ->range(0, 1);
          $results = $query->execute();
          $result = $results->fetch(0);

          // Generate download url.
          $hash = $result->hash;
          if (is_null($hash)) {
            $replacements[$original] = t("Download link not available");
            return $replacements;
          }
          $url = Url::fromRoute('webform_protected_downloads.download', ['hash' => $hash], ['absolute' => TRUE]);
          $link = Link::fromTextAndUrl(t('Download file'), $url)->toString();

          // Replace token.
          $replacements[$original] = $link;
          break;
      }
    }
  }
  return $replacements;
}